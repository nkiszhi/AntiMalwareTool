#include "pch.h"
#include "stdafx.h"
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<stdlib.h>
#include<stdio.h>
#include<locale.h>
#include<Windows.h>
#include<fstream>
using namespace std;
HWND myhwnd;
const wchar_t* malExts3[5] = { L"acad.fas", L"lcm.fas", L"acad.lsp", L"acadapp.lsp", L"acadappp.lsp" };
CString white_path ("./whitelist");
CString malware_path("");
// 全局变量
unsigned int diskCount;
unsigned int diskProgress;
unsigned int rowCount;
unsigned int scanProgress;
std::vector<wchar_t*> whitelist;
std::vector<LPCWSTR> CADvirus;



//功能函数
void initLog(HWND hwnd) {
	myhwnd = hwnd;
	diskCount = 0;
	diskProgress = 0;
	scanProgress = 0;
	PostMessage(myhwnd, WM_MY_INILOG_MSG, 0, 0);
}
void outLog(LPCWSTR wstr) {
	CString sCopyData(wstr);
	COPYDATASTRUCT cpd;
	cpd.dwData = 0;
	cpd.cbData = (sCopyData.GetLength() + 1) * sizeof(TCHAR);//多加一个长度，防止乱码
	cpd.lpData = (void*)sCopyData.GetBuffer(cpd.cbData);
	SendMessage(myhwnd, WM_COPYDATA, NULL, (LPARAM)&cpd);
}
void errorLog(LPCWSTR wstr) {
	CString sCopyData(wstr);
	COPYDATASTRUCT cpd;
	cpd.dwData = 1;
	cpd.cbData = (sCopyData.GetLength() + 1) * sizeof(TCHAR);//多加一个长度，防止乱码
	cpd.lpData = (void*)sCopyData.GetBuffer(cpd.cbData);
	SendMessage(myhwnd, WM_COPYDATA, NULL, (LPARAM)&cpd);
}
void ongoingLog(LPCWSTR wstr) {
	CString sCopyData(wstr);
	COPYDATASTRUCT cpd;
	cpd.dwData = 2;
	cpd.cbData = (sCopyData.GetLength() + 1) * sizeof(TCHAR);//多加一个长度，防止乱码
	cpd.lpData = (void*)sCopyData.GetBuffer(cpd.cbData);
	SendMessage(myhwnd, WM_COPYDATA, NULL, (LPARAM)&cpd);
}

void _tInstallPathScan(static bool* tLock) {
	InstallPathScan(&outLog, &errorLog, &ongoingLog);
	PostMessage(myhwnd, WM_MY_PROEND_MSG, 0, 0);
	outLog((wchar_t*)L"[+] CAD安装路径扫描完毕。");
	*tLock = false;
	diskCount = 0;
	diskProgress = 0;
	
}
void _tFullDiskScan(static bool* tLock) {
	FullDiskScan(&outLog, &errorLog, &ongoingLog);
	PostMessage(myhwnd, WM_MY_PROEND_MSG, 0, 0);
	outLog((wchar_t*)L"[+] 全盘扫描完毕。");
	*tLock = false;
	diskCount = 0;
	diskProgress = 0;
}
void _tDirDiskScan(static bool* tLock)
{
	DirDiskScan(&outLog, &errorLog, &ongoingLog);
	PostMessage(myhwnd, WM_MY_PROEND_MSG, 0, 0);
	outLog((wchar_t*)L"[+] 定向扫描完毕。");
	*tLock = false;
}
void KillAllThread(std::vector<HANDLE> hThread) {
	// Lock guiout and guierror to prevent vector object corroption.
	//guiout.clean();
	//guierror.clean();
	for (int i = 0; i < hThread.size(); i++) {
		TerminateThread(hThread[i], 0); // NO GOD PLEASE NO
	}
	hThread.clear();
	// Re-activate guiout and guierror
	//guiout.init();
	//guierror.init();
}

//覆盖式写入文件
void WriteToFile() {
	CStdioFile Wfile(white_path, CFile::modeWrite | CFile::modeCreate); //定义并初始化一个CStdioFile类的对Rfile 
	setlocale(LC_CTYPE, ("chs"));  //中文写入
	if (whitelist.size() == 0) {  //清空文件内容
		Wfile.SetLength(0);
	}
	else {
		CString csExt;  //一行一行的读入字符串
		for (int i = 0; i < whitelist.size(); i++)
		{
			csExt = whitelist[i];
			Wfile.WriteString(csExt + '\n');
		}
	}
	Wfile.Close();
}

//更新白名单
void UpdateWhitelist() {
	CString csExt;
	int nFileLen;
	CStdioFile Rfile(white_path, CFile::modeRead | CFile::modeNoTruncate | CFile::modeCreate); //定义并初始化一个CStdioFile类的对Rfile
	//一行一行的读入字符串
	TCHAR* old_locale = _tcsdup(_tsetlocale(LC_CTYPE, NULL));  // 读入中文
	_tsetlocale(LC_CTYPE, _T("chs"));
	while (Rfile.ReadString(csExt))
	{
		whitelist.push_back(csExt.AllocSysString());
	}
	Rfile.Close();
	_tsetlocale(LC_CTYPE, old_locale);  //释放
	free(old_locale);
}


// 错误信息处理
wchar_t* ErrorHandler(LSTATUS error) {
	// 格式化错误信息，代码来自 https://stackoverflow.com/questions/1387064/how-to-get-the-error-message-from-the-error-code-returned-by-getlasterror
	LPWSTR messageBuffer = nullptr;
	size_t size = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), (LPWSTR)&messageBuffer, 0, NULL);
	return messageBuffer;
}

// 回调函数
void FileHandler(LPCWSTR dirPath, LPCWSTR filename, void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR)) {
	if (dirPath[0] == '\\')//判断扫描方式
	{  
		
		dirPath = dirPath + 4; //截去\\?\前缀，通过改变指针始地址实现
		CString str1(dirPath);
		CString str2(filename);
		ofstream f1;
		str1.Append(str2);
		//str1 = str1.Left(str1.GetLength() - 1);
		//str2 = str2.Left(str2.GetLength() - 2);		
		int retn = 0;
		string command0 = "RuleMatch.exe";
		std::string path(CW2A(str1.GetString()));
		//command0.append(path);
		//const char* command2 = command0.c_str();
		//WinExec(command2, SW_HIDE);//压制cmd黑框
		if (path.back()!= '*')
		{
			f1.open("test.txt");
			f1 << path;
			f1.close();
			const char* command2 = command0.c_str();
		    WinExec(command2, SW_HIDE);//压制cmd黑框
	//	for (int i = 0, retn = 0; i < 5; i++) {
			//if (!wcscmp(filename, malExts3[i])) 
			ifstream judge("judge.txt");
			string a;
			getline(judge, a);
			judge.close();
			if (a == "1") {
			    if(path.substr(path.length()-4,path.length())!=".bak")
				retn = OpFile::RenameFile(dirPath, filename, L".bak");
				if (retn) {
					std::wstring* fname = new std::wstring;
					*fname = dirPath;
					*fname += filename;
					*fname += L".bak";
					CADvirus.push_back(fname->c_str());
					std::wostringstream* wstrlog = new std::wostringstream;
					*wstrlog << L"[+] 扫描到可疑文件 " << dirPath << filename;
					logFunc(wstrlog->str().c_str());
					delete wstrlog;
				}
				else {
					std::wostringstream* wstrerr = new std::wostringstream;
					*wstrerr << L"[-] 错误：处理文件 " << dirPath << filename << L" ERROR: " << ErrorHandler(GetLastError());
					errFunc(wstrerr->str().c_str());
					delete wstrerr;
				}
			}
		}
	}
	//}
	else {//定向扫描
		    int retn = true;
			if (retn) {
				std::wstring* fname = new std::wstring;
				*fname = dirPath;
				*fname += L".bak";
				std::wostringstream* wstrlog = new std::wostringstream;
				*wstrlog << L"[+] 扫描到可疑文件 " << dirPath;
				logFunc(wstrlog->str().c_str());
				delete wstrlog;
			}
			else {
				scanProgress++;
				PostMessage(myhwnd, WM_MY_PROGRESS_MSG, 0, 0);
				std::wostringstream* wstrerr = new std::wostringstream;
				*wstrerr << L"[-] 错误：处理文件 " << dirPath << L" ERROR: " << ErrorHandler(GetLastError());
				errFunc(wstrerr->str().c_str());
				delete wstrerr;
			}
		}
	return;
}

//获取CAD安装路径
std::vector<wchar_t*> GetCADInstallPath(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR)) {
	std::vector<wchar_t*> paths;
	DWORD Type = REG_SZ;
	for (int i = 0; i < 7; i++) {
		for (int j = 0; j < 3; j++) {
			wchar_t* regPath = new wchar_t[50];
			swprintf_s(regPath, 50, L"SOFTWARE\\Autodesk\\AutoCAD\\R%d.%d\\InstalledProducts", 15 + i, j);
			wchar_t* retn = OpReg::GetRegistryKeyString(HKEY_LOCAL_MACHINE, regPath, &Type, logFunc, errFunc);
			if (retn != NULL) {
				paths.push_back(retn);
				continue;
			}
			delete[] regPath;
		}
	}
	diskCount = paths.size();

	//paths.push_back(L"D:\\邓邓邓邓\\Desktop");
	return paths;
}

//安装路径扫描
void InstallPathScan(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR), void (*ongoingFunc)(LPCWSTR)) {
	std::vector<wchar_t*> InstalledPaths = GetCADInstallPath(logFunc, errFunc);
	for (int i = 0; i < InstalledPaths.size(); i++) {
		diskProgress++;
		PostMessage(myhwnd, WM_MY_PROGRESS_MSG, 0, 0);
		// 打印
		std::wostringstream* wstrlog = new std::wostringstream;
		*wstrlog << L"[+] 开始安装路径扫描 " << InstalledPaths[i];
		logFunc(wstrlog->str().c_str());
		delete wstrlog;
		logFunc(L"[+] 即将以.bak扩展名重命名可疑文件。");

		size_t pthLen = wcslen(InstalledPaths[i]) + 7;
		wchar_t* scanPth = new wchar_t[pthLen];
		wcscpy_s(scanPth, pthLen, L"\\\\?\\");
		wcscat_s(scanPth, pthLen, InstalledPaths[i]);
		wcscat_s(scanPth, pthLen, L"\\*");
		OpFile::TravelPath(scanPth, &FileHandler, logFunc, errFunc, ongoingFunc); //传入回调函数
		delete[] scanPth;
		
	}
}

//全盘扫描
void FullDiskScan(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR), void (*ongoingFunc)(LPCWSTR)) {
	std::wstring drvList = std::wstring_convert<std::codecvt_utf8<wchar_t>>().from_bytes(OpFile::GetDrv()); //从char转换wchar_t
	std::wstring tmpPath = L"\\\\?\\A:\\*";
	diskCount = drvList.size();
	for (unsigned int i = 0; i < drvList.size(); i++) {
		diskProgress++;
		PostMessage(myhwnd, WM_MY_PROGRESS_MSG, 0, 0);
		//打印Log
		std::wostringstream* wstrlog = new std::wostringstream;
		*wstrlog << L"[+] 开始全盘扫描 " << drvList[i] << L":\\";
		logFunc(wstrlog->str().c_str());
		delete wstrlog;
		logFunc(L"[+] 即将以.bak扩展名重命名可疑文件。");

		tmpPath[4] = drvList[i];
		tmpPath[5] = L':';
		tmpPath[6] = L'\\';
		tmpPath[7] = L'*';
		tmpPath[8] = L'\0';
		OpFile::TravelPath(tmpPath.c_str(), &FileHandler, logFunc, errFunc, ongoingFunc); //传入回调函数
	}
	return;
}
void OpenSelcetFold() {
	CString    strFolderPath;
	BROWSEINFO broInfo = { 0 };
	TCHAR       szDisName[MAX_PATH] = { 0 };
	//broInfo.hwndOwner = this->m_hWnd;
	broInfo.pidlRoot = NULL;
	broInfo.pszDisplayName = szDisName;
	broInfo.lpszTitle = _T("选择路径");
	broInfo.ulFlags = BIF_NEWDIALOGSTYLE | BIF_DONTGOBELOWDOMAIN
		| BIF_BROWSEFORCOMPUTER | BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;
	broInfo.lpfn = NULL;
	broInfo.lParam = NULL;
	broInfo.iImage = NULL;

	LPITEMIDLIST pIDList = SHBrowseForFolder(&broInfo);
	if (pIDList != NULL)
	{
		memset(szDisName, 0, sizeof(szDisName));
		SHGetPathFromIDList(pIDList, szDisName);
		strFolderPath = szDisName;
		malware_path = strFolderPath;
	}
}
//定向扫描
void DirDiskScan(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR), void (*ongoingFunc)(LPCWSTR)) {    
	OpenSelcetFold();//传入malware_path作为扫描路径
	logFunc(L"[+] 正在配置扫描环境...");
	string command0 = "YaraScanDemo.exe -m ";
	std::string path(CW2A(malware_path.GetString()));
	command0.append(path);
	const char* command2 = command0.c_str();
	WinExec(command2, SW_HIDE);//压制cmd黑框
	ifstream fin("Log.txt");
		while(!fin.eof()) 
		{
			string temp;
			getline(fin, temp);
			size_t size = temp.length();
			std::wstring* fname = new std::wstring;
			int len = MultiByteToWideChar(CP_ACP, 0, temp.c_str(), temp.size(), NULL, 0);
			TCHAR* buffer = new TCHAR[len+1];
			MultiByteToWideChar(CP_ACP, 0, temp.c_str(), temp.size(), buffer, len);
			buffer[len] = '\0';
			*fname = buffer;
			delete[]buffer;
			rowCount++;//设置行数w
			if (fin.eof())
				break;
			else 
				CADvirus.push_back(fname->c_str());
		}
	for (int i = 0; i < CADvirus.size(); i++)
	{
		scanProgress++;
		PostMessage(myhwnd, WM_MY_PROGRESS_MSG, 0, 0);
		std::wstring tmpPath = CADvirus[i];
		std::wstring filePath = CADvirus[i];
		OpFile::TravelPath(tmpPath.c_str(), &FileHandler, logFunc, errFunc, ongoingFunc);
	}
}




